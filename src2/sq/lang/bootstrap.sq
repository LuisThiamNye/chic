
(Alias-Classes
  ConcurrentHashMap java.util.concurrent.ConcurrentHashMap
  MHLookup java.lang.invoke.MethodHandles$Lookup
  MethodHandle java.lang.invoke.MethodHandle
  MethodHandles java.lang.invoke.MethodHandles
  MethodType java.lang.invoke.MethodType
  CallSite java.lang.invoke.CallSite
  SwitchPoint java.lang.invoke.SwitchPoint
  MutableCallSite java.lang.invoke.MutableCallSite
  ConstantCallSite java.lang.invoke.ConstantCallSite)

(defclass sq.lang.BootstrapInfoProvider
  (def ^:pub-pkg map (nw ConcurrentHashMap))
  (defn ^:pub get [^Object key]
    (.get map key)))

(defclass sq.lang.InternalDataContainer
  (def map (nw ConcurrentHashMap)))

(defclass sq.lang.DynClassMethodCallSite
  :super MutableCallSite
  [^MHLookup lk ^String method-name ^String target-classname]
  
  (init [_ ^MHLookup lk' ^String mn ^MethodType type ^String tc]
    (init-super type)
    (set! lk lk')
    (set! method-name mn)
    (set! target-classname tc))
  
  (defi ^:priv reset ^void [self]
    (l= map (jf sq.lang.InternalDataContainer :map))
    (l= target-class
      (.lookupClass
        (ct MHLookup
          (.get (ct ConcurrentHashMap
                  (.get map "hclassLookups"))
            target-classname))))
    (when (nil? target-class)
      (set! target-class (jc Class forName target-classname false
                           (.getClassLoader (.lookupClass lk)))))
    (l= type (.type self))
    (l= method (ji target-class getMethod method-name (.parameterArray type)))
    (l= target-mh (.unreflect lk method))
    (l= fallback-mh
      (do (l= lk' (jc MethodHandles lookup))
        (.asType
          (.asCollector
           (.bind lk' self "fallback"
             (jc MethodType methodType
               (jc Class forName "java.lang.Object")
               (jc Class forName "[Ljava.lang.Object;")))
           (jc Class forName "[Ljava.lang.Object;")
           (.parameterCount type))
          type)))
    (l= sw (ct SwitchPoint (.get map "dynclsSwitchPoint")))
    (.setTarget self (.guardWithTest sw target-mh fallback-mh)))
  
  (defi fallback ^Object [self ^"[Ljava.lang.Object;" args]
    (.reset self)
    (.invokeWithArguments (.getTarget self) args))
  
  (defn ^:pub bootstrap
    ^CallSite [^MHLookup lk ^String method-name ^MethodType type
               ^String target-classname]
    (l= cs (nw Self lk method-name type target-classname))
    (.reset cs)
    cs)
  )

;; FIXME too similar to above
(defclass sq.lang.DynConstructorCallSite
  :super MutableCallSite
  [^MHLookup lk ^String target-classname]
  
  (init [_ ^MHLookup lk' ^MethodType type ^String tc]
    (init-super type)
    (set! lk lk')
    (set! target-classname tc))
  
  (defi ^:priv reset ^void [self]
    (l= map (jf sq.lang.InternalDataContainer :map))
    (l= target-class
      (.lookupClass
        (ct MHLookup
          (.get (ct ConcurrentHashMap
                  (.get map "hclassLookups"))
            target-classname))))
    (when (nil? target-class)
      (set! target-class (jc Class forName target-classname false
                           (.getClassLoader (.lookupClass lk)))))
    (l= type (.type self))
    (l= method (.getConstructor target-class (.parameterArray type)))
    (.println (jf System out) "WOODOSODOO")
    (l= target-mh (.asType (.unreflectConstructor lk method) type))
    (l= fallback-mh
      (do (l= lk' (jc MethodHandles lookup))
        (.asType
          (.asCollector
           (.bind lk' self "fallback"
             (jc MethodType methodType
               (jc Class forName "java.lang.Object")
               (jc Class forName "[Ljava.lang.Object;")))
           (jc Class forName "[Ljava.lang.Object;")
           (.parameterCount type))
          type)))
    (l= sw (ct SwitchPoint (.get map "dynclsSwitchPoint")))
    (.setTarget self (.guardWithTest sw target-mh fallback-mh)))
  
  (defi fallback ^Object [self ^"[Ljava.lang.Object;" args]
    (.reset self)
    (.invokeWithArguments (.getTarget self) args))
  
  (defn ^:pub bsm
    ^CallSite [^MHLookup lk ^String method-name ^MethodType type
               ^String target-classname]
    (=: cs (nw Self lk type target-classname))
    (.reset cs)
    cs)
  )

(Alias-Classes
  Enum java.lang.Enum)

(defclass sq.lang.EnumSwitchMapCallSite
  ;; enum->idx
  ; :super MutableCallSite
  ; [^MHLookup lk ^String enum-classname ^"[Ljava.lang.String;" enums]
  
  ; (defn ^:priv make-mh ^MethodHandle
  ;   [^MHLookup lk ^String method-name ^MethodType type
  ;    ^String enum-classname ^"[Ljava.lang.String;" enums]
  ;   )
  
  (defn bsm ^CallSite
    [^MHLookup lk ^String method-name ^MethodType type
     ^String enum-classname ^"[Ljava.lang.Object;" enum-names]
    (=: cs-enum-class (.parameterType type 0))
    (if (.isInterface cs-enum-class)
      nil ;; TODO use dynamic impl
      ;; callsite coupled to runtime enum class
      (do
        (=: enum-class (jc Class forName enum-classname false
                         (.getClassLoader (.lookupClass lk))))
        (=: switchmap (na int (alength (.getEnumConstants enum-class))))
        (loop [i (- (alength enum-names) 1)]
          (when (<= 0 i)
            (=: name (ct String (aa enum-names i)))
            ;; case indexes from 1->n, considering uninitialised 0s in array
            (sa switchmap (.ordinal (jc Enum valueOf enum-class name))
              (+ i 1))
            (recur (- i 1))))
        ;; TODO optimise if ordinals = case indexes,
        ;; or constant offset eg 0,1,2 -> 1,2,3
        ;; if in reverse order, negate and offset: 2,1,0->-2,-1,0->1,2,3
        ;; if two non-adjacent contiguous chunks, use 'if' to offset first
        ;; (assuming earlier cases are more frequent, so no branch)
        ;; then offset both: 0,1,4,5->2,3,4,5->1,2,3,4
        ;; thus lookupswitch on 2 cases never needs array
        (nw ConstantCallSite
          (jc MethodHandles collectArguments
            (.bindTo (jc MethodHandles arrayElementGetter (.getClass switchmap))
              switchmap)
            0
            (.findVirtual lk enum-class "ordinal"
              (jc MethodType methodType (jf Integer TYPE)))))))))








