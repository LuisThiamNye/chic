
(Refer-Classes
  (sq.lang.util
    Ints2 Maths RopeCharacterIterator EmptyCharacterIterator RopeUtil
    IteratorIterable)
  (io.lacuna.bifurcan Set Map List LinearList Rope IList)
  (java.util ArrayList HashMap LinkedList)
  (java.util.function UnaryOperator Consumer IntBinaryOperator IntConsumer)
  (java.util.concurrent.atomic AtomicReference)
  (java.util.concurrent ConcurrentHashMap)
  (java.nio.file Path Files OpenOption StandardOpenOption LinkOption)
  (java.nio.file.attribute FileAttribute)
  (io.github.humbleui.types IRect Rect RRect)
  (io.github.humbleui.jwm
    EventMouseButton EventMouseMove EventMouseScroll
    EventKey EventWindowFocusOut App Window EventWindowResize EventTextInput
    EventFrame Platform Event
    EventWindowScreenChange EventWindowClose EventWindowCloseRequest
    MouseButton KeyModifier Key ClipboardFormat ClipboardEntry Clipboard)
  (io.github.humbleui.jwm.skija
    EventFrameSkija LayerD3D12Skija LayerGLSkija LayerMetalSkija)
  (io.github.humbleui.skija
    Canvas Paint PaintMode Font TextLine Typeface FontStyle)
  (com.ibm.icu.text BreakIterator)
  (chic.sqeditor
    RectTools UiRoot TextEditor Interactor IntrMgr Buffer View Selection
    Region RegionOps SelectionOps Misc RegionPathOps BreakNav EditorCommit
    TextButtonList BufferOps)
  (chic.sqeditor.i LineOffsetConverter))

(Alias-Classes
  SkPath io.github.humbleui.skija.Path)

(defclass chic.sqeditor.RectTools
  
  (defn contains-point? ^boolean [^Rect rect ^int ix ^int iy]
    (=: x (+ (ct float ix) 0.5f))
    (=: y (+ (ct float iy) 0.5f))
    (and (<= (.getLeft rect) x)
      (<= (.getTop rect) y)
      (< x (.getRight rect))
      (< y (.getBottom rect))))
  
  (defn contains-point? ^boolean [^IRect rect ^int x ^int y]
    (and (<= (.getLeft rect) x)
      (<= (.getTop rect) y)
      (< x (.getRight rect))
      (< y (.getBottom rect))))
  
  (defn withPos ^IRect [^IRect rect ^int x ^int y]
    (jc IRect makeLTRB x y (.getWidth rect) (.getHeight rect)))
  )

(defclass chic.sqeditor.Interactor
  [^:mut ^IRect rect
   ^HashMap handlers]
  (init [_]
    (set! handlers (nw HashMap)))
  (defi add-listener [self k ^Consumer listener]
    (.put handlers k listener))
  (defi set-rect [self ^IRect new-rect]
    (set! rect new-rect))
  (defi getRect [_] rect)
  (defi handle-generic [self k evt]
    (when (not (nil? (=: h (.get handlers k))))
      (.accept (ct Consumer h) evt)))
  (defi handle-mousescroll ^void [self ^EventMouseScroll evt]
    (.handle-generic self :mouse-scroll evt))
  (defi handle-mousedown ^void [self ^EventMouseButton evt]
    (.handle-generic self :mouse-down evt))
  (defi handle-mouseup ^void [self ^EventMouseButton evt]
    (.handle-generic self :mouse-up evt))
  (defi handle-mousemove ^void [self ^EventMouseMove evt]
    (.handle-generic self :mouse-move evt))
  (defi handle-keydown ^void [self ^EventKey evt]
    (.handle-generic self :key-down evt))
  (defi handle-keyup ^void [self ^EventKey evt]
    (.handle-generic self :key-up evt))
  (defi handle-textinput ^void [self ^EventTextInput evt]
    (.handle-generic self :text-input evt))
  )

(defclass chic.sqeditor.IntrMgr
  [^ArrayList intrs
   ^:mut ^Interactor focused-intr]
  
  (init [_]
    (set! intrs (nw ArrayList)))
  
  (defi reg-intr! ^void [self intr]
    (.add intrs intr))
  
  (defi unreg-intr! ^void [self intr]
    (.remove intrs intr))
  
  (defi handle-mousescroll ^boolean [_ ^EventMouseScroll evt]
    (=: it (.iterator intrs))
    (loop []
      (when (.hasNext it)
        (let
          intr (ct Interactor (.next it))
          rect (.getRect intr)
          _handled? (when (jc RectTools contains-point?
                            rect (.getX evt) (.getY evt))
                      (do (.handle-mousescroll intr evt) nil))
          (recur))))
    true)
  
  (defi handle-mousedown ^boolean [_ ^EventMouseButton evt]
    (=: it (.iterator intrs))
    (loop []
      (when (.hasNext it)
        (let
          intr (ct Interactor (.next it))
          rect (.getRect intr)
          _handled? (when (jc RectTools contains-point?
                            rect (.getX evt) (.getY evt))
                      (do (set! focused-intr intr)
                        (.handle-mousedown intr evt) nil))
          (recur))))
    true)
  
  (defi handle-mouseup ^boolean [_ ^EventMouseButton evt]
    (=: it (.iterator intrs))
    (loop []
      (when (.hasNext it)
        (let
          intr (ct Interactor (.next it))
          rect (.getRect intr)
          _handled? (when (jc RectTools contains-point?
                            rect (.getX evt) (.getY evt))
                      (do (.handle-mouseup intr evt) nil))
          (recur))))
    true)
  (defi handle-mousemove ^boolean [_ ^EventMouseMove evt]
    true)
  (defi handle-keydown ^boolean [_ ^EventKey evt]
    (when (not (nil? focused-intr))
      (.handle-keydown focused-intr evt))
    true)
  (defi handle-keyup ^boolean [_ ^EventKey evt]
    (when (not (nil? focused-intr))
      (.handle-keyup focused-intr evt))
    true)
  (defi handle-textinput ^boolean [_ ^EventTextInput evt]
    (when (not (nil? focused-intr))
      (.handle-textinput focused-intr evt))
    true)
  )

(defclass chic.sqeditor.Misc
  
  (defn cursor->line-idx ^int [^LinearList line-start-idxs ^int cursor-idx]
    (let it (.iterator line-start-idxs)
      (loop [i -1]
        (if (.hasNext it)
          (let lsi (.intValue (ct Integer (.next it)))
            (if (< cursor-idx lsi)
              i
              (recur (inc i))))
          i))))
  )

(defclass chic.sqeditor.BreakNav
  
  (defn make-word-iter ^BreakIterator [^Rope rope]
    (let it (jc BreakIterator getWordInstance)
      (do (.setText it (if (= 0 (.size rope))
                         (nw EmptyCharacterIterator)
                         (nw RopeCharacterIterator rope)))
        it)))
  
  (defn make-line-iter ^BreakIterator [^Rope rope]
    (let it (jc BreakIterator getLineInstance)
      (do (.setText it (if (= 0 (.size rope))
                         (nw EmptyCharacterIterator)
                         (nw RopeCharacterIterator rope)))
        it)))
  
  (defn word-before ^int [^BreakIterator iter ^int idx0]
    (=: idx (.following iter (dec idx0)))
    (loop []
      (if (< 0 idx)
        (do (=: rs (.getRuleStatus iter)) ;; must be before .previous
          (set! idx (.previous iter))
          (if (or (< rs (jf BreakIterator WORD_NONE))
                (<= (jf BreakIterator WORD_NONE_LIMIT) rs))
            idx
            (recur)))
        0)))
  
  (defn word-after ^int [^BreakIterator iter ^int idx0]
    (let n (.last iter)
      (loop [idx (.following iter idx0)]
        (if (and (<= 0 idx) (not (= n idx)))
          (if (let rs (.getRuleStatus iter)
                ;; if not punctuation/space
                (or (< rs (jf BreakIterator WORD_NONE))
                  (<= (jf BreakIterator WORD_NONE_LIMIT) rs)))
            idx
            (recur (.next iter)))
          n)))))

(defclass chic.sqeditor.i.LineOffsetConverter
  :tag [:interface]
  (defabstract line-xpos->offset ^int [^int line-idx ^int xpos])
  (defabstract line-offset->xpos ^int [^int line-idx ^int offset]))

(defclass chic.sqeditor.Region
  [^:pub ^int start
   ^:pub ^int end ;; idx of active cursor, may be >= or < than start
   ^:pub ^int xpos ;; for vertical movement; else -1 
   ]
  (init [_ ^int s ^int e]
    (set! start s)
    (set! end e)
    (set! xpos -1))
  
  (init [_ ^int s ^int e ^int x]
    (set! start s)
    (set! end e)
    (set! xpos x))
  )

(defclass chic.sqeditor.RegionOps
  
  (defn min [^Region region]
    (jc Math min (jfi region :start) (jfi region :end)))
  
  (defn max [^Region region]
    (jc Math max (jfi region :start) (jfi region :end)))
  
  (defn caret? [^Region region]
    (= (jfi region :start) (jfi region :end)))
  
  (defn offset [^Region region ^int offset]
    (if (= 0 offset)
      region
      (nw Region (+ offset (jfi region :start)) (+ offset (jfi region :end)))))
  
  (defn end-moved-vertically
    ^Ints2 [^int end ^int xpos ^int dlines ^Rope rope ^LinearList line-start-idxs
            ^LineOffsetConverter lo]
    (=: line-idx (+ dlines (jc Misc cursor->line-idx line-start-idxs end)))
    (if (< line-idx 0)
      (nw Ints2 0 xpos)
      (if (<= (ct int (.size line-start-idxs)) line-idx)
        (nw Ints2 (ct int (.size rope)) xpos)
        (let
          lsi (.intValue (ct Integer (.nth line-start-idxs (ct long line-idx))))
          xpos' (if (<= 0 xpos)
                  xpos
                  (let
                    line-idx-before (jc Misc cursor->line-idx
                                      line-start-idxs end)
                    lsi-before (.intValue
                                 (ct Integer
                                   (.nth line-start-idxs
                                     (ct long line-idx-before))))
                    (.line-offset->xpos lo line-idx-before (- end lsi-before))))
          (nw Ints2 (+ lsi
                     (.line-xpos->offset lo line-idx xpos')) xpos')))))
  
  (defn simple-moved-vertically
    [^Region region type ^Rope rope ^boolean modify?
     ^LinearList line-start-idxs
     ^LineOffsetConverter lo]
    (=: end' 0)
    (=: xpos' -1)
    (<-
      (if (== :up type)
        (let r (jc Self end-moved-vertically (jfi region :end) (jfi region :xpos)
                 -1 rope line-start-idxs lo)
          (do (set! end' (jfi r :x1))
            (set! xpos' (jfi r :x2)))))
      (if (== :down type)
        (let r (jc Self end-moved-vertically (jfi region :end) (jfi region :xpos)
                 1 rope line-start-idxs lo)
          (do (set! end' (jfi r :x1))
            (set! xpos' (jfi r :x2)))))
      nil)
    (nw Region (if modify? (jfi region :start) end') end' xpos'))
  
  (defn simple-move-end ^Region
    [^Region region type ^Rope rope ^boolean modify?]
    (=: end' 0)
    (=: xpos' -1)
    (<-
      (if (== :left type)
        (if (or modify? (jc Self caret? region))
          (if (< 0 (=: end (jfi region :end)))
            (set! end' (dec end))
            nil)
          (set! end' (jc Self min region))))
      (if (== :right type)
        (if (or modify? (jc Self caret? region))
          (if (< (=: end (jfi region :end)) (.size rope))
            (set! end' (inc end))
            (do
              (set! end' end)
              nil))
          (set! end' (jc Self max region))))
      (if (== :line-start type)
        (let
          end (jfi region :end)
          lsi (inc (jc RopeUtil lastIndexOf rope 10 (dec end)))
          nwsi (if (= lsi (.size rope))
                 lsi
                 (loop [i lsi]
                   (let c (.nth rope i)
                     (if (or (= 32 c) (= 9 c)) ;; space, tab
                       (recur (inc i))
                       i))))
          (do
            (set! end' (if (= end nwsi)
                         lsi nwsi))
            (set! xpos' 0))))
      (if (== :line-end type)
        (do (=: next-lf-idx (jc RopeUtil indexOf rope 10 (jfi region :end)))
          (set! end'
            (if (<= 0 next-lf-idx)
              next-lf-idx
              (.size rope)))
          (set! xpos' (jf Integer MAX_VALUE))))
      (if (== :doc-start type)
        (set! end' 0))
      (if (== :doc-end type)
        (set! end' (ct int (.size rope))))
      (if (== :word-right type)
        (let word-iter (jc BreakNav make-word-iter rope)
          (set! end' (jc BreakNav word-after word-iter (jfi region :end)))))
      (if (== :word-left type)
        (let word-iter (jc BreakNav make-word-iter rope)
          (set! end' (jc BreakNav word-before word-iter (jfi region :end)))))
      nil)
    (nw Region (if modify? (jfi region :start) end') end' xpos'))
  
  (defn effective-range ^Ints2 [^Region region ^Rope rope]
    (if (= 0 (=: rope-size (.size rope)))
      (nw Ints2 0 0)
      (if (jc Self caret? region)
        (let
          end (jfi region :end)
          lsi (inc (jc RopeUtil lastIndexOf rope 10 (dec end)))
          next-lf-idx (jc RopeUtil indexOf rope 10 end)
          rope-size (.size rope)
          lei (if (<= 0 next-lf-idx) (inc next-lf-idx) rope-size)
          (nw Ints2 lsi lei))
        (nw Ints2
          (jc Self min region) (jc Self max region)))))
  )

(defclass chic.sqeditor.RegionPathOps
  
  (defn add-line-end- ^void [^SkPath path ^float border-radius ^float y ^int x0 ^int x1]
    (when (not (= x0 x1))
      (let
        bd (* 2f border-radius)
        brx (jc Math min border-radius (jc Math abs (/ (ct float (- x0 x1)) 2f)))
        bdx (* 2f brx)
        x0f (ct float x0) x1f (ct float x1)
        (if (< x1 x0)
          ;; join from right to left
          (do (.arcTo path (jc Rect makeLTRB (- x0f (* 2f brx)) (- y bd)
                             x0f y)
                0f 90f false)
            (.arcTo path (jc Rect makeLTRB x1f y
                           (+ x1f bdx) (+ y bd))
              270f -90f false))
          ;; join from left to right
          (do (.arcTo path (jc Rect makeLTRB x0f (- y bd)
                             (+ x0f bdx) y)
                180f -90f false)
            (.arcTo path (jc Rect makeLTRB (- x1f bdx) y
                           x1f (+ y bd))
              270f 90f false))))))
  
  (defn add-simple-first-line- ^void
    [^SkPath path ^int line-height ^float border-radius
     ^int first-line-x ^int first-end-x]
    (let
      bd (* 2f border-radius)
      brx (jc Math min border-radius (ct float (- first-end-x first-line-x)))
      bdx (* 2f brx)
      origin-y 0
      origin-yf (ct float origin-y)
      first-line-xf (ct float first-line-x)
      first-end-xf (ct float first-end-x)
      (do
        ;; top-left of first line
        (.moveTo path first-line-xf (+ origin-yf bd))
        (.arcTo path (jc Rect makeLTRB first-line-xf origin-yf
                       (+ first-line-xf bdx) (+ origin-yf bdx))
          180f 90f false)
        (.arcTo path (jc Rect makeLTRB (- first-end-xf bdx) origin-yf
                       first-end-xf (+ origin-yf bd))
          270f 90f false))))
  
  (defn add-first-line-leader- ^void
    [^SkPath path ^int line-height ^float border-radius ^int first-line-x]
    (let
      origin-x 0 origin-y 0
      origin-xf 0f origin-yf 0f
      bd (* 2f border-radius)
      first-line-xf (ct float first-line-x)
      y (ct float (+ origin-y line-height))
      bdx (jc Math min bd (ct float (- first-line-x origin-x)))
      (do
        ;; top-left of second line
        (.arcTo path (jc Rect makeLTRB
                       origin-xf y (+ origin-xf bdx) (+ y bd))
          180f 90f false)
        (.arcTo path (jc Rect makeLTRB
                       (- first-line-xf bdx) (- y bd) first-line-xf y)
          90f -90f false))))
  
  (defn compute-path ^SkPath [^int line-height ^IList line-end-xs ^float border-radius ^int first-line-x]
    (let
      path (nw SkPath)
      bd (* 2f border-radius) ;; border diameter
      bd-rounded (jc Math round bd)
      origin-x 0 origin-y 0
      first-end-x (.intValue (ct Integer (.nth line-end-xs 0L)))
      (do
        (jc Self add-simple-first-line- path line-height border-radius first-line-x first-end-x)
        (=: nlines (.size line-end-xs))
        (loop ;; right ends
          [y (+ line-height origin-y)
           prev-x first-end-x
           i 1L]
          (=: yf (ct float y))
          (if (< i nlines)
            (do (=: end-x (.intValue (ct Integer (.nth line-end-xs i))))
              (jc Self add-line-end- path border-radius yf prev-x end-x)
              (recur
                (+ y line-height)
                end-x
                (inc i)))
            (let
              x prev-x
              xf (ct float x)
              left-x (if (< 1L nlines) origin-x first-line-x)
              left-xf (ct float left-x)
              brx (jc Math min border-radius (ct float (- x origin-x)))
              bdx (* 2f brx)
              (do
                ;; bottom-right
                (.arcTo path (jc Rect makeLTRB (- xf bdx) (- yf bd) xf yf)
                  0f 90f false)
                ;; bottom-left
                (.arcTo path (jc Rect makeLTRB left-xf (- yf bd) (+ left-xf bdx) yf)
                  90f 90f false)
                (when (and (< 1L nlines) (< 0 first-line-x))
                  ;; the first line is offset and not alone
                  (do (jc Self add-first-line-leader- path line-height border-radius first-line-x)))))))
        (.closePath path))))
  )

(defclass chic.sqeditor.EditorCommit
  [^:pub ^Rope rope ^:pub ^"[Lchic.sqeditor.Region;" regions]
  (init [_ ^Rope r]
    (set! rope r))
  (init [_ ^Rope r ^"[Lchic.sqeditor.Region;" rs]
    (set! rope r)
    (set! regions rs))
  (init [_ ^Rope r ^LinearList rs]
    (set! rope r)
    (set! regions (ct "[Lchic.sqeditor.Region;" (.toArray rs)))))

(defclass chic.sqeditor.Buffer
  [^:pub ^:mut ^Rope rope
   ^:pub ^LinearList line-start-idxs
   ^:pub ^:mut ^Path path
   ^:pub ^:mut ^Rope saved-rope
   ^:pub ^ArrayList commits
   ^:pub ^ArrayList redo-commits
   ^:pub ^:mut ^EditorCommit latest-commit
   ^:pub ^:mut ^long last-commit-time]
  
  (defi set-rope ^void [_ ^Rope r]
    (set! rope r)
    (.clear line-start-idxs)
    (.addLast line-start-idxs (jc Integer valueOf 0))
    (=: it (.codePoints rope))
    (loop [i 1]
      (when (.hasNext it)
        (=: ich (.nextInt it))
        (when (= 10 ich)
          (.addLast line-start-idxs (jc Integer valueOf i)))
        (recur (inc i)))))
  
  (defi set-path ^void [_ ^Path f]
    (set! path f))
  
  (defi reload ^void [self]
    (=: rope (jc Rope from (jc Files readString path)))
    (.set-rope self rope)
    (set! saved-rope rope))
  
  (defi reset-history! ^void [_]
    (.clear commits)
    (.clear redo-commits)
    (set! last-commit-time (jc System currentTimeMillis))
    (set! latest-commit (nw EditorCommit rope)))
  
  (init [self]
    (set! commits (nw ArrayList))
    (set! redo-commits (nw ArrayList))
    (set! line-start-idxs (nw LinearList))
    (.set-rope self (jf Rope EMPTY))
    (.reset-history! self))
  
  (init [self ^Rope r]
    (set! commits (nw ArrayList))
    (set! redo-commits (nw ArrayList))
    (set! line-start-idxs (nw LinearList))
    (.set-rope self r)
    (.reset-history! self))
  )

(defclass chic.sqeditor.Selection
  [^:pub ^:mut ^LinearList regions]
  (init [_]
    (set! regions (nw LinearList)))
  (defi clear ^void [_]
    (set! regions (nw LinearList)))
  #_(defi reset-regions! [_ ^LinearList regions']
    (set! regions regions'))
  (defi reset-regions! [_ ^"[Lchic.sqeditor.Region;" regions']
    (set! regions (nw LinearList (alength regions')))
    (loop [i 0]
      (when (< i (alength regions'))
        (.addLast regions (aa regions' i)))))
  )

(defclass chic.sqeditor.BufferOps
  
  (defn commit! [^Buffer buffer ^Selection sel ^EditorCommit commit]
    (=: latest-commit (jfi buffer :latest-commit))
    (=: next-rope (jfi commit :rope))
    (.set-rope buffer next-rope)
    (when (not (nil? (=: regions (jfi commit :regions))))
      (.reset-regions! sel regions)))
  
  (defn edit! [^Buffer buffer ^Selection sel ^EditorCommit commit]
    (=: prev-rope (jfi buffer :rope))
    (=: next-rope (jfi commit :rope))
    (when (not (== prev-rope next-rope))
      (=: t (jc System currentTimeMillis))
      (=: latest-commit (jfi buffer :latest-commit))
      (when (nil? (jfi latest-commit :regions))
        ;; save regions prior to the next commit, useful for initial commit
        (set! latest-commit
          (setf! buffer :latest-commit
            (nw EditorCommit (jfi latest-commit :rope) (jfi sel :regions)))))
      (=: should-commit?
        (let
          dt (- t (jfi buffer :last-commit-time))
          nchardiff 1
          thres (ct long (* 3400 (jc Math exp (* -0.0027 (ct double nchardiff)))))
          (<= thres dt)))
      (when should-commit?
        (.add (jfi buffer :commits) latest-commit)
        (setf! buffer :last-commit-time t)
        (setf! buffer :latest-commit commit))
      (jc Self commit! buffer sel commit)))
  
  (defn undo! [^Buffer buffer ^Selection sel]
    (=: prev-rope (jfi buffer :rope))
    (=: commits (jfi buffer :commits))
    (=: latest-commit (jfi buffer :latest-commit))
    (=: ncommits (.size commits))
    (if (= 0 ncommits)
      (setf! buffer :latest-commit
        (nw EditorCommit (jfi latest-commit :rope) 
          (ct "[LRegion;" nil)))
      (jc Self commit! buffer sel
        (ct EditorCommit
          (if (== (jfi latest-commit :rope) prev-rope)
            ;; no uncommitted changes
            (do (.add (jfi buffer :redo-commits) latest-commit)
              (setf! buffer :latest-commit (.remove commits (dec ncommits))))
            ;; else uncommitted changes
            (do (.add (jfi buffer :redo-commits)
                  (nw EditorCommit prev-rope (jfi sel :regions)))
              latest-commit))))))
  
  (defn redo! [^Buffer buffer ^Selection sel]
    (=: redo-commits (jfi buffer :redo-commits))
    (when (< 0 (=: nredos (.size redo-commits)))
      (=: com (.remove redo-commits (dec nredos)))
      (=: latest-commit (jfi buffer :latest-commit))
      (=: commits (jfi buffer :commits))
      (.add commits latest-commit)
      (=: rope (jfi buffer :rope))
      (when (not (== (jfi latest-commit :rope) rope))
        (.add commits (nw EditorCommit rope (jfi sel :regions))))
      (setf! buffer :latest-commit com)
      (jc Self commit! buffer sel (ct EditorCommit com))))
  
  (defn dirty? [^Buffer buffer]
    (and (not (nil? (jfi buffer :path)))
      (not (== (jfi buffer :saved-rope) (jfi buffer :rope)))))
  
  (defn save! ^void [^Buffer buffer]
    (=: rope (jfi buffer :rope))
    (=: path (jfi buffer :path))
    (jc Files createDirectories
      (.getParent path)
      (na FileAttribute 0))
    (jc Files writeString path
      (.toString rope)
      (let a (na OpenOption 0)
        (do #_(sa a 0 (jf StandardOpenOption CREATE))
          a)))
    (setf! buffer :saved-rope rope))
  )

(defclass chic.sqeditor.SelectionOps
  
  (defn add-region! ^void [^LinearList regions ^Region region]
    (.addLast regions region))
  
  (defn add ^void [^Selection sel ^Region region]
    (.addLast (jfi sel :regions) region))
  
  (defn simple-moved-vertically ^void [^Selection sel type ^Rope rope ^boolean modify?
                                       ^LinearList line-start-idxs
                                       ^LineOffsetConverter lo]
    (=: regions (jfi sel :regions))
    (.clear sel)
    (let it (.iterator regions)
      (loop []
        (when (.hasNext it)
          (jc Self add sel (jc RegionOps simple-moved-vertically
                             (ct Region (.next it)) type rope modify?
                             line-start-idxs
                             lo))
          (recur)))))
  
  (defn simple-move-ends ^void [^Selection sel type ^Rope rope ^boolean modify?]
    (=: regions (jfi sel :regions))
    (.clear sel)
    (let it (.iterator regions)
      (loop []
        (when (.hasNext it)
          (jc Self add sel (jc RegionOps simple-move-end
                             (ct Region (.next it)) type rope modify?))
          (recur)))))
  
  (defn reg-ary [^LinearList regions]
    (ct "[Lchic.sqeditor.Region;" (.toArray regions)))
  
  (defn insert-text ^EditorCommit [^Selection sel ^Rope rope ^String text]
    (=: prev-regions (jfi sel :regions))
    (=: regions (nw LinearList))
    (let it (.iterator prev-regions)
      (loop [rope rope
             offset 0]
        (if (.hasNext it)
          (do (=: region (ct Region (.next it)))
            (=: start (+ offset (jc RegionOps min region)))
            (=: end (+ offset (jc RegionOps max region)))
            (=: text-length (.length text))
            (=: end' (+ start text-length))
            (=: rope (if (= start end)
                       rope
                       (.remove rope start end)))
            (jc Self add-region! regions (nw Region end' end'))
            (recur (.insert rope start text)
              (+ offset (- text-length (- end start)))))
          (do (nw EditorCommit rope (jc Self reg-ary regions)))))))
  
  (defn delete-by-movement ^EditorCommit [^Selection sel type ^Rope rope]
    (=: regions (nw LinearList))
    (let it (.iterator (jfi sel :regions))
      (loop [rope rope
             offset 0]
        (if (.hasNext it)
          (let
            region (jc RegionOps offset (ct Region (.next it)) offset)
            region' (jc RegionOps simple-move-end region type rope true)
            high (+ offset (jc RegionOps max region'))
            low (+ offset (jc RegionOps min region'))
            (do (jc Self add-region! regions (nw Region low low))
              (recur
                (.remove rope low high)
                (- offset (- high low)))))
          (nw EditorCommit rope (jc Self reg-ary regions))))))
  
  (defn delete-backward ^EditorCommit [^Selection sel ^Rope rope]
    ;; may want behaviour of deleting multiple spaces of tab size etc
    (=: regions (nw LinearList))
    (let it (.iterator (jfi sel :regions))
      (loop [rope rope
             offset 0]
        (if (.hasNext it)
          (do (=: region (ct Region (.next it)))
            (=: end (+ offset (jc RegionOps max region)))
            (=: start (+ offset (jc RegionOps min region)))
            (when (and (= start end) (< 0 end))
              (set! start (dec end)))
            (=: end' (jc Math min start end))
            (jc Self add-region! regions (nw Region end' end'))
            (if (= 0 end)
              (recur rope offset)
              (recur (.remove rope start end)
                (- offset (- end start)))))
          (nw EditorCommit rope (jc Self reg-ary regions))))))
  
  (defn delete ^EditorCommit [^Selection sel ^Rope rope]
    (let
      regions (nw LinearList)
      it (.iterator (jfi sel :regions))
      (loop [rope rope
             offset 0]
        (if (.hasNext it)
          (let
            region (jc RegionOps offset (ct Region (.next it)) offset)
            ab (jc RegionOps effective-range region rope)
            a (jfi ab :x1)
            b (jfi ab :x2)
            (do
              (jc Self add-region! regions (nw Region a a))
              (recur (.remove rope a b)
                (+ offset (- b a)))))
          (nw EditorCommit rope (jc Self reg-ary regions))))))
  
  (defn select-all ^void [^Selection sel ^Rope rope]
    (=: regions (jfi sel :regions))
    (.clear regions)
    (.addLast regions (nw Region 0 (ct int (.size rope)))))
  
  (defn combined-regions-str ^String [^Selection sel ^Rope rope]
    (let
      regions (jfi sel :regions)
      sb (nw StringBuilder)
      it (.iterator regions)
      (loop []
        (if (.hasNext it)
          (let region (ct Region (.next it))
            (do
              (when (< 0 (.length sb))
                (.append sb \newline))
              (let
                  ab (jc RegionOps effective-range region rope)
                  a (jfi ab :x1)
                  b (jfi ab :x2)
                (do (.append sb (.toCharSequence
                                  (.slice rope a b)))
                  (when (and (jc RegionOps caret? region)
                          (= b (.size rope)))
                    (.append sb \newline))))
              (recur)))
          (.toString sb)))))
  )

(defclass chic.sqeditor.View
  :interfaces AutoCloseable
  [^:pub ^Buffer buffer
   ^:pub ^Selection selection]
  
  (init [_ ^Buffer b]
    (set! buffer b)
    (set! selection (nw Selection)))
  
  ; (defi retarget [_])
  ; (defi dirty? [_])
  
  (defi close ^void [_]))

(defclass chic.sqeditor.TextButtonList
  [^IntConsumer on-click
   ^:mut ^int y-top
   ^:mut ^int y-bottom
   ^:mut ^int item-height]
  
  (init [_ ^IntConsumer f]
    (set! on-click f))
  
  (defi draw [_ ^IRect rect ^Canvas cnv ^Iterable labels ^Font font ^Paint fill]
    (=: height (ct int (.getSpacing font)))
    (set! item-height height)
    (set! y-top (.getTop rect))
    (=: x (ct float (.getLeft rect)))
    (=: it (.iterator labels))
    (=: offset (- height (ct int (.getDescent (.getMetrics font)))))
    (loop [y (+ (.getTop rect) offset)]
      (if (.hasNext it)
        (let label (ct String (.next it))
          textline (jc TextLine make label font)
          (do (.drawTextLine cnv textline x y fill)
            (recur (+ y height))))
        (set! y-bottom (- y offset)))))
  
  (defi on-mouse-down ^void [_ ^EventMouseButton evt]
    (=: idx
      (/ (jc Math min (dec y-bottom) (- (.getY evt) y-top)) item-height))
    (.accept on-click idx))
  )

(defclass chic.sqeditor.TextEditor
  :interfaces AutoCloseable
  [^RRect border-rrect
   ^Paint border-paint-focused
   ^:mut ^IRect visible-rect
   ^:mut ^View view
   ^ArrayList views
   ^:pub ^:mut ^LinearList textlines
   ^:mut ^int line-height
   ^:mut ^int plane-origin-x
   ^:mut ^int plane-origin-y
   ^:mut ^Font font
   ^:mut ^Font ui-font
   ^:mut ^Paint text-paint
   ^:mut ^boolean dragging?
   ^Interactor intr
   ^Interactor sidebar-intr
   ^:pub ^TextButtonList ui-sidebar
   ^IntrMgr intrmgr
   ^:mut ^int scroll-x
   ^:mut ^int scroll-y]
  
  (defi draw-text [self ^Rect rect ^Canvas cnv]
    (=: min-vis-idx (/ (- (.getTop visible-rect) plane-origin-y)
                      line-height))
    (=: nlines (ct int (.size textlines)))
    (=: max-vis-idx (jc Math min
                      (dec nlines)
                      (/ (- (.getBottom visible-rect) plane-origin-y)
                        line-height)))
    (loop [i min-vis-idx
           y (- (+ (* (inc i) line-height) plane-origin-y)
               (jc Math round (.getDescent (.getMetrics font))))]
      (when (<= i max-vis-idx)
        (.drawTextLine cnv (ct TextLine (.nth textlines i))
          (ct float plane-origin-x) (ct float y) text-paint)
        (recur (inc i) (+ y line-height)))))
  
  (defi line-offset->xpos ^int [self ^int line-idx ^int offset]
    (let text-line (ct TextLine (.nth (jfi self :textlines) (ct long line-idx)))
      (jc Math round (.getCoordAtOffset text-line offset))))
  
  (defi get-line-start-idx ^int [self ^int line-idx]
    (.intValue
      (ct Integer
        (.nth (jfi (jfi view :buffer) :line-start-idxs)
          (ct long line-idx)))))
  
  (defi cursor-idx->xpos ^int [self ^int cursor-idx]
    (=: line-start-idxs (jfi (jfi view :buffer) :line-start-idxs))
    (=: line-idx (jc Misc cursor->line-idx line-start-idxs cursor-idx))
    (=: start-idx
      (.intValue
        (ct Integer
          (.nth line-start-idxs
            (ct long line-idx)))))
    (=: offset (- cursor-idx start-idx))
    (.line-offset->xpos self line-idx offset))
  
  (defi draw-selection-region [self ^Region region ^Canvas cnv]
    (=: line-start-idxs (jfi (jfi view :buffer) :line-start-idxs))
    (=: end-idx (jfi region :end))
    (=: start-idx (jfi region :start))
    (=: end-line-idx (jc Misc cursor->line-idx line-start-idxs end-idx))
    (=: start-line-idx (jc Misc cursor->line-idx line-start-idxs start-idx))
    (=: region-nlines (inc (- end-line-idx start-line-idx)))
    (=: top-idx (jc Math min start-idx end-idx))
    (=: top-line-idx (jc Math min start-line-idx end-line-idx))
    (=: bottom-line-idx (jc Math max start-line-idx end-line-idx))

    (=: nlines (.size line-start-idxs))
    (=: line-end-xs (nw LinearList region-nlines))
    (=: nl-width (ct int (.measureTextWidth font "\n")))
    (loop [i top-line-idx]
      (if (< i bottom-line-idx)
        (do
          (.addLast line-end-xs
            (jc Integer valueOf
              (+ nl-width
                (.line-offset->xpos self i (jf Integer MAX_VALUE)))))
          (recur (inc i)))
        (.addLast line-end-xs
          (jc Integer valueOf
            (.line-offset->xpos self i
              (- (jc Math max start-idx end-idx)
                (.get-line-start-idx self i)))))))
    
    (=: first-line-x (.cursor-idx->xpos self top-idx))
    (=: border-radius (* 0.15f (ct float line-height)))
    
    (=: region-paint (nw Paint))
    (.setColor region-paint 0xFFB4D8FD)
    (.drawPath cnv
      (.offset (jc RegionPathOps compute-path line-height line-end-xs border-radius first-line-x)
        (ct float plane-origin-x)
        (ct float (+ plane-origin-y (* line-height top-line-idx))))
      region-paint))
  
  (defi draw-region-cursor [self ^Region region ^Canvas cnv]
    (=: line-start-idxs (jfi (jfi view :buffer) :line-start-idxs))
    (=: end-idx (jfi region :end))
    (=: end-line-idx (jc Misc cursor->line-idx line-start-idxs end-idx))
    (=: line-top (+ (* end-line-idx line-height) plane-origin-y))
    
    (=: line-start-idx (.intValue
                         (ct Integer
                           (.nth line-start-idxs (ct long end-line-idx)))))
    (=: offset (- end-idx line-start-idx))
    (=: text-line (ct TextLine (.nth textlines (ct long end-line-idx))))
    (=: cursor-brx (.getCoordAtOffset text-line offset))
    (=: cursor-x (ct float (+ cursor-brx (ct float plane-origin-x))))
    (=: cursor-width 2f)
    
    (=: cursor-paint (nw Paint))
    (.setColor cursor-paint 0xE0007ACC)
    (=: extra-v (jc Math round (* 0.12f (ct float line-height))))
    (.drawRect cnv
      (jc Rect makeLTRB
        (- cursor-x (/ cursor-width 2f))
        (ct float (- line-top extra-v))
        (+ cursor-x (/ cursor-width 2f))
        (ct float (+ line-top line-height extra-v)))
      cursor-paint))
  
  (def text-padding-h 5)
  (def text-padding-v 3)
  (def sidebar-width 350)
  
  (defi draw ^void [self ^IRect irect ^Canvas cnv]
    (=: irect
      (jc IRect makeLTRB
        (+ sidebar-width (.getLeft irect))
        (+ (.getTop irect) (ct int (.getSpacing ui-font)) 5)
        (.getRight irect)
        (- (.getBottom irect) 20)))
    
    (=: sidebar-rect (jc IRect makeLTRB 0 0 sidebar-width (.getBottom irect)))
    (.set-rect sidebar-intr sidebar-rect)
    (=: sidebar-labels
      (let
        list (nw ArrayList)
        (loop [i (dec (.size views))]
          (if (<= 0 i)
            (let
              v (ct View (.get views i))
              path (jfi (jfi v :buffer) :path)
              (do (.add list (if (nil? path)
                               "<no file>"
                               (.toString path)))
                (recur (dec i))))
            list))))
      (let n (.save cnv)
        (try
          (.clipRect cnv (.toRect sidebar-rect))
          (.draw ui-sidebar sidebar-rect cnv sidebar-labels ui-font text-paint)
          (finally
            (.restoreToCount cnv n))))
    
    (=: regions (jfi (jfi view :selection) :regions))
    (when (< 0 (.size regions))
      (=: line-num (inc (jc Misc cursor->line-idx
                          (jfi (jfi view :buffer) :line-start-idxs)
                          (jfi (ct Region (.nth regions 0)) :end))))
      (.drawString cnv (jc String valueOf line-num)
        sidebar-width (- (.getSpacing font)
                        (.getDescent (.getMetrics font)))
        font text-paint))
    
    (when (jc BufferOps dirty? (jfi view :buffer))
      (.setStrokeWidth text-paint 6)
      (.drawPoint cnv (+ sidebar-width 3) 3 text-paint))
    (set! visible-rect irect)
    (.set-rect intr irect)
    (set! plane-origin-x (+ text-padding-h scroll-x (.getLeft irect)))
    (set! plane-origin-y (+ text-padding-v scroll-y (.getTop irect)))
    
    ;; region highlights
    (=: it (.iterator (jfi (jfi view :selection) :regions)))
    (loop []
      (when (.hasNext it)
        (=: region (ct Region (.next it)))
        (when (not (jc RegionOps caret? region))
          (.draw-selection-region self region cnv))
        (recur)))
    
    (=: rect (.toRect irect))
    (.draw-text self rect cnv)
    
    ;; cursors
    (=: it (.iterator (jfi (jfi view :selection) :regions)))
    (loop []
      (when (.hasNext it)
        (=: region (ct Region (.next it)))
        (.draw-region-cursor self region cnv)
        (recur)))
    (=: border-rrect (.withRadii rect 2f))
    
    (.drawRRect cnv border-rrect border-paint-focused))
  
  (defi on-mouse-down [self ^EventMouseButton evt]
    (when (== (jf MouseButton PRIMARY) (.getButton evt))
      (=: selection (jfi view :selection))
      (.clear selection)
      
      (=: dy (- (.getY evt) plane-origin-y))
      (=: brx (- (.getX evt) plane-origin-x))
      (=: target-line-idx (/ dy line-height))
      (=: line-start-idxs (jfi (jfi view :buffer) :line-start-idxs))
      (=: max-line-idx (dec (ct int (.size line-start-idxs))))
      (=: line-idx (jc Maths clamp target-line-idx 0 max-line-idx))
      (=: text-line (ct TextLine (.nth textlines (ct long line-idx))))
      (=: offset (.getOffsetAtCoord text-line (ct float brx)))
      (=: cursor-idx (+ (.intValue
                          (ct Integer
                            (.nth line-start-idxs (ct long line-idx))))
                       offset))
      (jc SelectionOps add selection (nw Region cursor-idx cursor-idx))
      (set! dragging? true)))
  
  (defi on-mouse-up [self ^EventMouseButton evt]
    (when (== (jf MouseButton PRIMARY) (.getButton evt))
      (set! dragging? false)))
  
  ; (defi move-right [self]
  ;   (=: rope (jfi (jfi view :buffer) :rope))
    
  ;   (if ()))
  
  (defi regenerate-textlines! [self ^Rope rope]
    (=: line-start-idxs (jfi (jfi view :buffer) :line-start-idxs))
    (=: textlines' (nw LinearList (ct int (.size line-start-idxs))))
    (=: it (.iterator line-start-idxs))
    (loop [prev-i (.intValue (ct Integer (.next it)))]
      (if (.hasNext it)
        (let lsi (.intValue (ct Integer (.next it)))
          (do (.addLast textlines'
                (jc TextLine make
                  ;; dec to exclude newline
                  (.toString (.slice rope prev-i (dec lsi))) font))
            (recur lsi)))
        (.addLast textlines'
          (jc TextLine make
            (.toString (.slice rope prev-i (.size rope))) font))))
    (set! textlines textlines'))
  
  (defi perform-edit! ^void [self ^EditorCommit commit]
    (jc BufferOps edit! (jfi view :buffer)
      (jfi view :selection) commit)
    (.regenerate-textlines! self (jfi commit :rope)))
  
  (defi perform-undo ^void [self]
    (=: buffer (jfi view :buffer))
    (jc BufferOps undo! buffer (jfi view :selection))
    (.regenerate-textlines! self (jfi buffer :rope)))
  
  (defi perform-redo ^void [self]
    (=: buffer (jfi view :buffer))
    (jc BufferOps redo! buffer (jfi view :selection))
    (.regenerate-textlines! self (jfi buffer :rope)))
  
  (defi navigateFromRegion ^void [self]
    (=: nav-loc (jc SelectionOps combined-regions-str
                  (jfi view :selection) (jfi (jfi view :buffer) :rope)))
    (=: path (jc java.nio.file.Path of
               (.concat (.concat "src3/" nav-loc) ".sq") (na String 0)))
    (=: buffer' (nw Buffer))
    (.set-path buffer' path)
    (=: view' (nw View buffer'))
    (set! view view')
    (.add views view')
    (jc SelectionOps add (jfi view' :selection) (nw Region 0 0))
    (if (jc Files exists path (na LinkOption 0))
      (try
        (.reload buffer')
        (.regenerate-textlines! self
          (jfi buffer' :rope))
        (catch java.io.IOException e
          (.println (jf System out) "Could not load file")
          (.println (jf System out) e)))
      (.regenerate-textlines! self
        (jf Rope EMPTY))))
  
  (defi close-current ^void [self]
    (=: n (.size views))
    (when (and (< 1 n)
            (not (jc BufferOps dirty? (jfi view :buffer))))
      (.remove views (dec n))
      (set! view (.get views (- n 2)))
      (.regenerate-textlines! self
        (jfi (jfi view :buffer) :rope))))
  
  (defi on-key-down ^void [self ^EventKey evt]
    (=: mods (bit-and (jfi evt :_modifiers) (bit-not 1)))
    (=: rope (jfi (jfi view :buffer) :rope))
    (=: key (.getKey evt))
    (when (.isArrowKey key)
      (set! mods (bit-and mods (bit-not 512))))
    (=: lo
      (reify LineOffsetConverter
        (line-xpos->offset ^int [_ ^int line-idx ^int xpos]
          (let text-line (ct TextLine (.nth (jfi self :textlines) (ct long line-idx)))
            (.getOffsetAtCoord text-line (ct float xpos))))
        (line-offset->xpos ^int [_ ^int line-idx ^int offset]
          (.line-offset->xpos self line-idx offset))))
    (=: line-start-idxs (jfi (jfi view :buffer) :line-start-idxs) )
    (=: shift? (.isModifierDown evt (jf KeyModifier SHIFT)))
    (=: macos? (== (jf Platform MACOS) (jf Platform CURRENT)))
    (=: control? (.isModifierDown evt (jf KeyModifier CONTROL)))
    (=: primary? (.isModifierDown evt
                   (if macos?
                     (jf KeyModifier MAC_COMMAND)
                     (jf KeyModifier CONTROL))))
    (=: option? (.isModifierDown evt (jf KeyModifier MAC_OPTION)))
    (if primary?
      (case-enum key
        A (jc SelectionOps select-all (jfi view :selection) rope)
        V (let data (jc Clipboard get (let a (na ClipboardFormat 1)
                                        (do (sa a 0 (jf ClipboardFormat TEXT))
                                          a)))
            (when (not (nil? data))
              (.perform-edit! self
                (jc SelectionOps insert-text (jfi view :selection)
                  (jfi (jfi view :buffer) :rope) (.getString data)))))
        C (let s (jc SelectionOps combined-regions-str (jfi view :selection) rope)
            (jc Clipboard set (let a (na ClipboardEntry 1)
                                (do (sa a 0 (jc ClipboardEntry makeString
                                              (jf ClipboardFormat TEXT) s))
                                  a))))
        X (do (let s (jc SelectionOps combined-regions-str (jfi view :selection) rope)
                (jc Clipboard set (let a (na ClipboardEntry 1)
                                    (do (sa a 0 (jc ClipboardEntry makeString
                                                  (jf ClipboardFormat TEXT) s))
                                      a))))
            (.perform-edit! self
              (jc SelectionOps delete (jfi view :selection)
                (jfi (jfi view :buffer) :rope))))
        Z (if shift? (.perform-redo self) (.perform-undo self))
        S (jc BufferOps save! (jfi view :buffer))
        W (.close-current self)
        G (.navigateFromRegion self)
        HOME (jc SelectionOps simple-move-ends (jfi view :selection) :doc-start rope shift?)
        END (jc SelectionOps simple-move-ends (jfi view :selection) :doc-end rope shift?)
        (when macos?
          (case-enum key
            LEFT (jc SelectionOps simple-move-ends (jfi view :selection) :line-start rope shift?)
            RIGHT (jc SelectionOps simple-move-ends (jfi view :selection) :line-end rope shift?)
            UP (jc SelectionOps simple-move-ends (jfi view :selection) :doc-start rope shift?)
            DOWN (jc SelectionOps simple-move-ends (jfi view :selection) :doc-end rope shift?)
            BACKSPACE (.perform-edit! self
                        (jc SelectionOps delete-by-movement (jfi view :selection) :line-start rope))
            nil)))
      ;; non primary
      (if (if macos? option? control?)
        (case-enum key
          RIGHT (jc SelectionOps simple-move-ends (jfi view :selection) :word-right rope shift?)
          LEFT (jc SelectionOps simple-move-ends (jfi view :selection) :word-left rope shift?)
          nil)
        (case-enum key
          RIGHT (jc SelectionOps simple-move-ends (jfi view :selection) :right rope shift?)
          LEFT (jc SelectionOps simple-move-ends (jfi view :selection) :left rope shift?)
          UP (jc SelectionOps simple-moved-vertically (jfi view :selection) :up rope shift?
               line-start-idxs lo)
          DOWN (jc SelectionOps simple-moved-vertically (jfi view :selection) :down rope shift?
                 line-start-idxs lo)
          BACKSPACE (.perform-edit! self
                      (jc SelectionOps delete-backward (jfi view :selection)
                        (jfi (jfi view :buffer) :rope)))
          ENTER (.perform-edit! self
                  (jc SelectionOps insert-text (jfi view :selection)
                    (jfi (jfi view :buffer) :rope) "\n"))
          HOME (jc SelectionOps simple-move-ends (jfi view :selection) :line-start rope shift?)
          END (jc SelectionOps simple-move-ends (jfi view :selection) :line-end rope shift?)
          nil))))
  
  (defi on-text-input ^void [self ^EventTextInput evt]
    (.perform-edit! self
      (jc SelectionOps insert-text (jfi view :selection)
        (jfi (jfi view :buffer) :rope) (.getText evt))))
  
  (defn scroll-offset ^int [^int prev ^int content-length ^int visible-length
                            ^int delta]
    (if (<= content-length visible-length)
      0
      (jc Maths clamp
        (+ prev delta)
        (- visible-length content-length)
        0)))
  
  (defi on-mouse-scroll ^void [self ^EventMouseScroll evt]
    (=: visible-width (.getWidth visible-rect))
    (=: content-width
      (loop [i (dec (.size textlines))
             acc 0]
        (if (<= 0 i)
          (let textline (ct TextLine (.nth textlines i))
            (recur (dec i)
              (jc Math max acc (ct int (jc Math ceil (.getWidth textline))))))
          (+ acc (* 2 text-padding-h)))))
    (set! scroll-x (jc Self scroll-offset scroll-x content-width visible-width
                     (ct int (.getDeltaX evt))))
    (=: visible-height (.getHeight visible-rect))
    (=: content-height (+ (* (ct int (.size textlines)) line-height)
                         text-padding-v
                         40))
    (set! scroll-y (jc Self scroll-offset scroll-y content-height visible-height
                     (ct int (.getDeltaY evt)))))
  
  (defi set-view-idx ^void [self ^int idx]
    (set! view (.remove views (- (.size views) idx 1)))
    (.add views view)
    (.regenerate-textlines! self (jfi (jfi view :buffer) :rope)))
  
  (init [self ^IntrMgr intrmgr']
    ;; interactor
    (set! intrmgr intrmgr')
    (set! intr (nw Interactor))
    (.reg-intr! intrmgr' intr)
    (.add-listener intr :mouse-down
      (reify Consumer
        (accept ^void [_ evt]
          (.on-mouse-down self (ct EventMouseButton evt)))))
    (.add-listener intr :mouse-up
      (reify Consumer
        (accept ^void [_ evt]
          (.on-mouse-up self (ct EventMouseButton evt)))))
    (.add-listener intr :mouse-scroll
      (reify Consumer
        (accept ^void [_ evt]
          (.on-mouse-scroll self (ct EventMouseScroll evt)))))
    (.add-listener intr :key-down
      (reify Consumer
        (accept ^void [_ evt]
          (.on-key-down self (ct EventKey evt)))))
    (.add-listener intr :text-input
      (reify Consumer
        (accept ^void [_ evt]
          (.on-text-input self (ct EventTextInput evt)))))
    
    (set! sidebar-intr (nw Interactor))
    (.reg-intr! intrmgr' sidebar-intr)
    (set! ui-sidebar (nw TextButtonList
                       (reify IntConsumer
                         (accept ^void [_ ^int idx]
                           (.set-view-idx self idx)))))
    (.add-listener sidebar-intr :mouse-down
      (reify Consumer
        (accept ^void [_ evt]
          (.on-mouse-down (jfi self :ui-sidebar) (ct EventMouseButton evt)))))
    
    (set! border-paint-focused
      (let p (nw Paint)
        (do (.setColor p 0x5f000000)
          (.setMode p (jf PaintMode STROKE))
          (.setStrokeWidth p 2f)
          p)))
    (=: buffer (nw Buffer))
    (.set-path buffer (jc Path of "src3/home.sq" (na String 0)))
    (.reload buffer)
    (.reset-history! buffer)
    (=: view' (nw View buffer))
    (set! view view')
    (set! views (nw ArrayList))
    (.add views view)
    (jc SelectionOps add (jfi view' :selection) (nw Region 0 0))
    
    (set! font (nw Font (jc Typeface makeFromName "InputSansCondensed"
                          (jf FontStyle NORMAL))
                 30f))
    (set! ui-font (.makeWithSize font 28f))
    (set! line-height (jc Math round (.getSpacing font)))
    (set! text-paint (nw Paint))
    (.setColor text-paint 0xFF000000)
    
    (.regenerate-textlines! self (jfi buffer :rope)))
  
  (defi close ^void [_]
    (.unreg-intr! intrmgr intr)
    (.unreg-intr! intrmgr sidebar-intr))
  )

(defclass chic.sqeditor.UiRoot
  :interfaces AutoCloseable
  [^:mut ^TextEditor texteditor
   ^IntrMgr intrmgr]
  
  (init [self ^IntrMgr intrmgr']
    (set! intrmgr intrmgr')
    (set! texteditor (nw TextEditor intrmgr')))
  
  (defi draw [self ^IRect rect ^Canvas cnv]
    ;; TODO 5 padding
    (try (.draw texteditor rect cnv)
      (catch ClassCastException e
        (.close (ct AutoCloseable texteditor))
        (set! texteditor (nw TextEditor intrmgr))
        (throw e))))
  ;; 200-wide sidebar
  ;; address bar
  ;; text box
  
  (defi close ^void [_]
    (.close texteditor))
  )

(defclass chic.sqeditor.Window
  :interfaces chic.window.i.PaintAndEventHandler AutoCloseable
  [^:mut ^Window jwm-window
   ^:mut ^Rect content-rect
   ^:mut ^float scale
   ^:mut ^int mouse-x
   ^:mut ^int mouse-y
   ^IntrMgr intrmgr
   ^UiRoot root]
  
  (init [_]
    (set! intrmgr (nw IntrMgr))
    (set! root (nw UiRoot intrmgr)))
  
  (defi set-window [_ ^Window jwin]
    (set! jwm-window jwin)
    (.setTitle jwin "Squawk")
    (set! scale (.getScale (.getScreen jwin)))
    ; (.setWindowSize - - -)
    ; (.setWindowPosition - - -)
    )
  
  (defi paint ^void [_ ^Canvas cnv]
    (.clear cnv 0xFFffffff)
    (.draw root (jc RectTools withPos (.getContentRect jwm-window) 0 0) cnv))
  
  (defi notifyEvent ^void [self ^Event evt]
    (when
      (<-
        (if (instance? EventMouseMove evt)
          (do (set! mouse-x (.getX (ct EventMouseMove evt)))
            (set! mouse-y (.getY (ct EventMouseMove evt)))
            true))
        (if (instance? EventKey evt)
          (let evt (ct EventKey evt)
            (if (.isPressed evt)
              (.handle-keydown intrmgr evt)
              (.handle-keyup intrmgr evt))))
        (if (instance? EventTextInput evt)
          (let evt (ct EventTextInput evt)
            (.handle-textinput intrmgr evt)))
        (if (instance? EventWindowResize evt)
          (let cr (.getContentRect jwm-window)
            (do (set! content-rect (jc Rect makeLTRB 0 0 (.getRight cr) (.getBottom cr)))
              true)))
        (if (instance? EventMouseScroll evt)
          (.handle-mousescroll intrmgr (ct EventMouseScroll evt)))
        (if (instance? EventMouseButton evt)
          (let evt (ct EventMouseButton evt)
            (if (.isPressed evt)
              (.handle-mousedown intrmgr evt)
              (.handle-mouseup intrmgr (ct EventMouseButton evt)))))
        (if (instance? EventWindowScreenChange evt)
          (do (set! scale (.getScale (.getScreen jwm-window)))
            true))
        (if (instance? EventWindowCloseRequest evt)
          (do (.close jwm-window)
            false))
        (if (instance? EventWindowClose evt)
          (do (.close self)
            false))
        false)
      (.requestFrame jwm-window)))
  
  (defi close ^void [self]
    (jc chic.window.Main unreg-window! self)
    (.close root))
  
  (defn spawn []
    (=: self (nw Self))
    (let jwin (jc chic.window.Main new-jwm-window)
      (try
        (.set-window self jwin)
        (.setEventListener jwin (nw chic.window.StdWinEventListener self))
        (.setWindowPosition jwin -1800 50)
        (.setVisible jwin true)
        (.focus jwin)
        (jc chic.window.Main reg-window! self)
        (catch Throwable e
          (.close jwin)
          (jc chic.window.Main unreg-window! self)
          (throw e)))))
  )





"
UI Components: ideally one component per potentially unique lifetime
"